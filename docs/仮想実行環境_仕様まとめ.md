参考：ECMA-335 12章

# 12. Virtual Execution System (仮想実行環境)

## 12.1. 直接サポートするデータ型

|データ型           |評価スタックへの展開|説明|
|:------------------|:------------------:|:---|
|int8               |                    |
|unsigned int8      |                    |
|int16              |                    |
|unsigned int16     |                    |
|int32              |yes                 |
|unsigned int32     |                    |
|int64              |yes                 |
|unsigned int64     |                    |
|float32            |                    |
|float64            |                    |
|native int         |yes                 |符号付きネイティブサイズ整数
|native unsigned int|                    |符号なしネイティブサイズ整数
|F                  |                    |VES内部浮動小数
|O                  |                    |ネイティブサイズオブジェクト参照
|&                  |                    |ネイティブサイズマネージドポインタ

評価スタックのポインタオフセットは4または8バイトのみ
任意のサイズのユーザー定義値型は実体を評価スタックに配置できるが、組み込み演算はアドレスに対してのみ実行できる

## ネイティブサイズの型

### アンマネージドポインタ(native unsigned int)

VESの管理外ポインタ、すなわちアンマネージドポインタは評価スタック上ではnative unsigned intとして展開される。

### オブジェクト参照(`O`)およびマネージドポインタ(`&`)

オブジェクト参照が利用できる命令は参照型が利用できる命令(`ceq`、`ldind.ref`など)、メタデータ参照を利用する命令(`call`, `ldfld`など)に限られる

マネージドポインタはオブジェクト参照に似ているが、オブジェクトの内部を指すことができる

### 移植性：ポインタのメモリへの格納

1. ネイティブサイズのデータ型へのポインタは移植可能
2. 8バイトのデータ型へのポインタは移植可能
3. 4バイトのデータ型へのポインタは移植不能


## 値型インスタンスに対する動作

値型インスタンスを作成し、引数として渡し、値として返し、ローカル、フィールド、および配列の要素に格納したり、それらから抽出したりすることができます（すなわち、コピー）。

クラスと同様に、値の型は静的なメンバと非静的なメンバ（メソッドとフィールド）の両方を持つことができます。

しかし、実行時には型情報を持たないので、値型インスタンスは `System.Object` 型のアイテムの代用にはならない。

この点では、組み込み型の int32, int64 などと同じように動作します。
値型インスタンスとオブジェクトを変換する操作には、boxとunboxの2つがあります。

### 初期化

値型の初期化方法は3通り

1. ホームアドレスをロードして`initobj`。(ローカル変数の場合)またはメソッドヘッダに`localsinit`フラグを設定する
2. ホームアドレスをロードしてコンストラクタをコールする
3. 既存のインスタンスをホームアドレスにコピーする

### 読み込みと書き込み

評価スタックに値型を読み込む方法は2通り

- `ldarg`, `ldloc`, `ldfld`, `ldsfld`命令などでホームアドレスから直接ロード
- ホームアドレスを計算してから`ldobj`命令でロード

評価スタックに値型を書き込む方法は2通り

- `starg`, `stloc`, `stfld`, `stsfld`命令などでホームアドレスに直接ストア
- ホームアドレスを計算してから`stobj`命令でストア

### 引数への渡しと戻り値の取得

- 値型の値渡し：実体を評価スタックにロード(`ldloc`, `ldloc`など)して渡す
- 値型の参照渡し：ホームアドレスを評価スタックにロード(`ldloca`)
- 値型の戻し：実体を評価スタックにロードしてから`ret`

### メソッド呼び出し

- 静的メソッドに対しては通常のクラスと同様に呼び出す
- インスタンスメソッドに対しては、最初のパラメータ(インスタンス)にホームアドレスを渡す
- ボックス化されたインスタンスに対しては、イカの3通り
  - 値型自体のインスタンスメソッド・仮想メソッド：アンボクシングして呼び出す
  - 基底クラスの仮想メソッド：｀System.Object`、`System.ValueType`、`System.Enum`などのクラス上で呼び出す
  - インターフェースの仮想メソッド：そのインターフェースのメソッドを`callvirt`で呼び出す

## 12.3.2.1. 評価スタック

1. プログラムの任意の時点での評価スタックの状態は、すべての可能な制御フロー・パスに対して同一でなければならない。

2. CLIは評価スタック上における値の型が以下のうちのいずれかに該当することを要求する
   - `int64`
   - `int32`
   - `native int`
   - `F`
   - `&`
   - `O`
   - `*` 一時ポインタ
   - ユーザー定義値型

3. 2.に含まれない型は以下のルールで2.のいずれかの型に変換してスタックに置かれる
   - 8bitおよび16bitの整数型は`int32`で保持される。これらの型の識別は命令が担当する
   - ヒープ外を指すポインタ(`ldloca`, `ldarga`, `ldsflda`)は一時ポインタ`*`を生成する。
     この型はマネージドポインタ`&`とアンマネージポインタ`native int`のいずれとしても扱える。
   - アンマネージポインタは`native int`として扱われる。
   - メソッドコールにおいては、アンマネージポインタはマネージドポインタを要求するパラメータとしても利用できる
   - マネージドポインタはアンマネージポインタに変換できる。
