<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Reflection.Emit" #>
<#@ output extension=".g.cs" #>
// <auto-generated>
// THIS (.g.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
#pragma warning disable CS0162
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

namespace PowerEmit.Disassemblies
{
    partial class ILDisassembler
    {
        protected virtual void DisassembleNextOpCode(int currentIndex, short opcode)
        {
            switch(opcode)
            {
<#
foreach(var (name, opcode) in OpCodeInfos)
{
#>
            case OpCodeConst.<#=name#>:
                {
<#=string.Join("\r\n", GetOperationText(name, opcode).Select(line => "                    " + line))#>
                }
                return;
<#
}
#>
            default:
                throw new NotImplementedException();
            }
        }
    }
}
#pragma warning restore CS0162
<#+
static (string name, OpCode opcode)[] OpCodeInfos = typeof(OpCodes)
    .GetFields(BindingFlags.Public | BindingFlags.Static)
    .Where(fi => fi.FieldType == typeof(OpCode))
    .Select(fi => (name: fi.Name, opcode: (OpCode)fi.GetValue(null)))
    .Where(tpl => tpl.opcode.Value < OpCodes.Prefix7.Value)
    .OrderBy(tpl => (ushort)tpl.opcode.Value)
    .ToArray();


public static string[] GetOperationText(string name, OpCode opcode)
{
    switch(opcode.OperandType)
    {
    case OperandType.InlineBrTarget:
        return new []{
            $"var offset = ReadStreamHead<int>();",
            $"PushOperation(OpCodeX.{name}(GetOrAddLabel(currentIndex + OpCodes.{name}.GetTotalByteSize() + offset)));",
        };
    case OperandType.InlineField:
        return new []{
            $"var fld = Method.DeclaringType.Module.ResolveField(ReadStreamHead<int>());",
            $"PushOperation(OpCodeX.{name}(fld));",
        };
    case OperandType.InlineI:
        return new []{
            $"var value = ReadStreamHead<int>();",
            $"PushOperation(OpCodeX.{name}(value));",
        };
    case OperandType.InlineI8:
        return new []{
            $"var value = ReadStreamHead<long>();",
            $"PushOperation(OpCodeX.{name}(value));",
        };
    case OperandType.InlineMethod:
        return new []{
            $"var meth = ({(opcode == OpCodes.Newobj ? "ConstructorInfo" : "MethodInfo")})Method.DeclaringType.Module.ResolveMethod(ReadStreamHead<int>());",
            $"PushOperation(OpCodeX.{name}(meth));",
        };
    case OperandType.InlineNone:
        return new []{ 
            $"PushOperation(OpCodeX.{name}());",
        };
    case OperandType.InlineR:
        return new []{
            $"var value = ReadStreamHead<double>();",
            $"PushOperation(OpCodeX.{name}(value));",
        };
    case OperandType.InlineSig:
        return new []{
            $"// var sig = Method.DeclaringType.Module.ResolveSignature(ReadStreamHead<int>());",
            $"// PushOperation(OpCodeX.{name}(sig));",
            $"throw new NotSupportedException();",
        };
    case OperandType.InlineString:
        return new []{
            $"var str = Method.DeclaringType.Module.ResolveString(ReadStreamHead<int>());",
            $"PushOperation(OpCodeX.{name}(str));",
        };
    case OperandType.InlineSwitch:
        return new []{
            $"var labels = new LabelDescriptor[ReadStreamHead<int>()];",
            $"for(var i = 0; i < labels.Length; ++i)",
            @"{",
            $"    labels[i] = GetOrAddLabel(currentIndex + 4 * (1 + labels.Length) + ReadStreamHead<int>());",
            @"}",
            $"PushOperation(OpCodeX.{name}(labels));",
        };
    case OperandType.InlineTok:
        return new []{
            $"switch(Method.Module.ResolveMember(ReadStreamHead<int>()))",
            @"{",
            $"case Type type        : PushOperation(OpCodeX.Ldtoken(type));   break;",
            $"case MethodInfo method: PushOperation(OpCodeX.Ldtoken(method)); break;",
            $"case FieldInfo field  : PushOperation(OpCodeX.Ldtoken(field));  break;",
            $"default               : throw new InvalidOperationException();",
            @"}",
            $"throw new NotSupportedException();",
        };
    case OperandType.InlineType:
        return new []{
            $"var type = Method.DeclaringType.Module.ResolveType(ReadStreamHead<int>());",
            $"PushOperation(OpCodeX.{name}(type));",
        };
    case OperandType.InlineVar:
        return new []{
            $"var value = ReadStreamHead<ushort>();",
            $"PushOperation(OpCodeX.{name}(value));",
        };
    case OperandType.ShortInlineBrTarget:
        return new []{
            $"var offset = ReadStreamHead<sbyte>();",
            $"PushOperation(OpCodeX.{name}(GetOrAddLabel(currentIndex + OpCodes.{name}.GetTotalByteSize() + offset)));",
        };
    case OperandType.ShortInlineI:
        return new []{
            $"var value = ReadStreamHead<{(opcode == OpCodes.Unaligned ? "byte" : "sbyte")}>();",
            $"PushOperation(OpCodeX.{name}(value));",
        };
    case OperandType.ShortInlineR:
        return new []{
            $"var value = ReadStreamHead<float>();",
            $"PushOperation(OpCodeX.{name}(value));",
        };
    case OperandType.ShortInlineVar:
        return new []{
            $"var value = ReadStreamHead<byte>();",
            $"PushOperation(OpCodeX.{name}(value));",
        };
    default:
        break;
    }
    return new [] {
        "#warning not implemented"
    };
}
#>