<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Reflection.Emit" #>
<#@ output extension=".g.cs" #>
// <auto-generated>
// THIS (.g.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
#pragma warning disable CS0162
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

namespace PowerEmit.Disassemblers
{
    partial class ILDisassembler
    {
        partial class Entity
        {
            protected virtual partial void DisassembleNextOpCode(int currentIndex, short opcode)
            {
                switch(opcode)
                {
<#  foreach(var (name, opcode) in OpCodeInfos) { #>
                case OpCodeConst.<#=name#>:
                    {
<#=string.Join("\r\n", GetOperationText(name, opcode).Select(line => "                        " + line))#>
                    }
                    return;
<#  } #>
                default:
                    throw new NotImplementedException();
                }
            }
        }
    }
}
#pragma warning restore CS0162
<#+
static (string name, OpCode opcode)[] OpCodeInfos = typeof(OpCodes)
    .GetFields(BindingFlags.Public | BindingFlags.Static)
    .Where(fi => fi.FieldType == typeof(OpCode))
    .Select(fi => (name: fi.Name, opcode: (OpCode)fi.GetValue(null)))
    .Where(tpl => tpl.opcode.Value < OpCodes.Prefix7.Value)
    .OrderBy(tpl => (ushort)tpl.opcode.Value)
    .ToArray();

static OpCode[] AboutLocal = new []{
    OpCodes.Ldloc_0,
    OpCodes.Ldloc_1,
    OpCodes.Ldloc_2,
    OpCodes.Ldloc_3,
    OpCodes.Ldloc_S,
    OpCodes.Ldloc,
    OpCodes.Ldloca_S,
    OpCodes.Ldloca,
    OpCodes.Stloc_0,
    OpCodes.Stloc_1,
    OpCodes.Stloc_2,
    OpCodes.Stloc_3,
    OpCodes.Stloc_S,
    OpCodes.Stloc,
};
static OpCode[] AboutArgument = new []{
    OpCodes.Ldarg_0,
    OpCodes.Ldarg_1,
    OpCodes.Ldarg_2,
    OpCodes.Ldarg_3,
    OpCodes.Ldarg_S,
    OpCodes.Ldarg,
    OpCodes.Ldarga_S,
    OpCodes.Ldarga,
    OpCodes.Starg_S,
    OpCodes.Starg,
};


static string ResolveVar(OpCode opcode)
{
    if(AboutLocal.Contains(opcode))
        return "_locals[value]";
    if(AboutArgument.Contains(opcode))
        return "_arguments[value]";
    return "value";
}


public static string[] GetOperationText(string name, OpCode opcode)
{
    switch(opcode.OperandType)
    {
    case OperandType.InlineBrTarget:
        return new []{
            $"var offset = ReadStreamHead<int>();",
            $"PushOperation(Inst.{name}(GetOrAddLabel(currentIndex + OpCodes.{name}.GetTotalByteSize(offset) + offset)));",
        };
    case OperandType.InlineField:
        return new []{
            $"var fld = Method.DeclaringType.Module.ResolveField(ReadStreamHead<int>());",
            $"PushOperation(Inst.{name}(fld));",
        };
    case OperandType.InlineI:
        return new []{
            $"var value = ReadStreamHead<int>();",
            $"PushOperation(Inst.{name}(value));",
        };
    case OperandType.InlineI8:
        return new []{
            $"var value = ReadStreamHead<long>();",
            $"PushOperation(Inst.{name}(value));",
        };
    case OperandType.InlineMethod:
        return new []{
            $"var callable = Method.DeclaringType.Module.ResolveMethod(ReadStreamHead<int>());",
            $"if(callable is MethodInfo meth)",
            $"    PushOperation(Inst.{name}(meth));",
            $"else if(callable is ConstructorInfo ctor)",
            $"    PushOperation(Inst.{name}(ctor));",
        };
    case OperandType.InlineNone:
        return new []{ 
            $"PushOperation(Inst.{name}());",
        };
    case OperandType.InlineR:
        return new []{
            $"var value = ReadStreamHead<double>();",
            $"PushOperation(Inst.{name}(value));",
        };
    case OperandType.InlineSig:
        return new []{
            $"// var sig = Method.DeclaringType.Module.ResolveSignature(ReadStreamHead<int>());",
            $"// PushOperation(Inst.{name}(sig));",
            $"throw new NotSupportedException();",
        };
    case OperandType.InlineString:
        return new []{
            $"var str = Method.DeclaringType.Module.ResolveString(ReadStreamHead<int>());",
            $"PushOperation(Inst.{name}(str));",
        };
    case OperandType.InlineSwitch:
        return new []{
            $"var labels = new LabelBuilder[ReadStreamHead<int>()];",
            $"for(var i = 0; i < labels.Length; ++i)",
            @"{",
            $"    labels[i] = GetOrAddLabel(currentIndex + 4 * (1 + labels.Length) + ReadStreamHead<int>());",
            @"}",
            $"PushOperation(Inst.{name}(labels));",
        };
    case OperandType.InlineTok:
        return new []{
            $"switch(Method.Module.ResolveMember(ReadStreamHead<int>()))",
            @"{",
            $"case Type type        : PushOperation(Inst.Ldtoken(type));   break;",
            $"case MethodInfo method: PushOperation(Inst.Ldtoken(method)); break;",
            $"case FieldInfo field  : PushOperation(Inst.Ldtoken(field));  break;",
            $"default               : throw new InvalidOperationException();",
            @"}",
            $"throw new NotSupportedException();",
        };
    case OperandType.InlineType:
        return new []{
            $"var type = Method.DeclaringType.Module.ResolveType(ReadStreamHead<int>());",
            $"PushOperation(Inst.{name}(type));",
        };
    case OperandType.InlineVar:
        return new []{
            $"var value = ReadStreamHead<ushort>();",
            $"PushOperation(Inst.{name}(value));",
        };
    case OperandType.ShortInlineBrTarget:
        return new []{
            $"var offset = ReadStreamHead<sbyte>();",
            $"PushOperation(Inst.{name}(GetOrAddLabel(currentIndex + OpCodes.{name}.GetTotalByteSize(offset) + offset)));",
        };
    case OperandType.ShortInlineI:
        return new []{
            $"var value = ReadStreamHead<{(opcode == OpCodes.Unaligned ? "byte" : "sbyte")}>();",
            $"PushOperation(Inst.{name}(value));",
        };
    case OperandType.ShortInlineR:
        return new []{
            $"var value = ReadStreamHead<float>();",
            $"PushOperation(Inst.{name}(value));",
        };
    case OperandType.ShortInlineVar:
        return new []{
            $"var value = ReadStreamHead<byte>();",
            $"PushOperation(Inst.{name}(value));",
        };
    default:
        break;
    }
    return new [] {
        "#warning not implemented"
    };
}
#>