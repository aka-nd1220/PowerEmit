<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<# GenerateSource(); #>
<#+
void GenerateSource() {
    #nullable enable
    var testCases = new (string, string)[]
    {
        ("br"     , "Br"     ),
        ("brfalse", "Brfalse"),
        ("brtrue" , "Brtrue" ),
        ("beq"    , "Beq"    ),
        ("bge"    , "Bge"    ),
        ("bgt"    , "Bgt"    ),
        ("ble"    , "Ble"    ),
        ("blt"    , "Blt"    ),
        ("bne.un" , "Bne_Un" ),
        ("bge.un" , "Bge_Un" ),
        ("bgt.un" , "Bgt_Un" ),
        ("ble.un" , "Ble_Un" ),
        ("blt.un" , "Blt_Un" ),
    };
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection.Emit;
using System.Text;
using Xunit;

namespace PowerEmit
{
    public partial class InstTest
    {
        [Theory]
        [MemberData(nameof(GetTestCases_Branch))]
        public void Emit_Branch(TestCase testCase)
            => EmitCore(testCase);


        public static IEnumerable<object[]> GetTestCases_Branch()
        {
<#+
    foreach(var (lName, uName) in testCases) {
        foreach(var x in new []{ 0, -3, sbyte.MinValue, +1, sbyte.MaxValue }) {
            GenerateJumpTestCase(lName + ".s", uName + "_S", 2, x);
        }
        foreach(var x in new []{ 0, -6, sbyte.MinValue, sbyte.MinValue - 1, short.MinValue, +1, sbyte.MaxValue, sbyte.MaxValue + 1, short.MaxValue }) {
            GenerateJumpTestCase(lName, uName, 5, x);
        }
    }
#>
            yield break;
        }
    }
}
<#+
}


void GenerateJumpTestCase(string lName, string uName, int instSize, int iteration) {
#>
            {
                Action<ILGenerator> expected = gen => {
                    var label = gen.DefineLabel();
<#+ if(iteration < 0) { #>
                    gen.MarkLabel(label);
                    for(var i = -<#=instSize#>; i > <#=iteration#>; --i)
                        gen.Emit(OpCodes.Nop);
<#+ } #>
                    gen.Emit(OpCodes.<#=uName#>, label);
<#+ if(iteration >= 0) { #>
                    for(var i = 0; i < <#=iteration#>; ++i)
                        gen.Emit(OpCodes.Nop);
                    gen.MarkLabel(label);
<#+ } #>
                };
                Action<ILGenerator> actual_label = gen => {
                    var label = gen.DefineLabel();
<#+ if(iteration < 0) { #>
                    gen.MarkLabel(label);
                    for(var i = -<#=instSize#>; i > <#=iteration#>; --i)
                        gen.Emit(OpCodes.Nop);
<#+ } #>
                    gen.Emit(Inst.<#=uName#>(label));
<#+ if(iteration >= 0) { #>
                    for(var i = 0; i < <#=iteration#>; ++i)
                        gen.Emit(OpCodes.Nop);
                    gen.MarkLabel(label);
<#+ } #>
                };
                Action<ILGenerator> actual_labelBuilder = gen => {
                    var labelBuilder = new LabelBuilder("test label");
<#+ if(iteration < 0) { #>
                    labelBuilder.MarkLabel(gen);
                    for(var i = -<#=instSize#>; i > <#=iteration#>; --i)
                        gen.Emit(OpCodes.Nop);
<#+ } #>
                    gen.Emit(Inst.<#=uName#>(labelBuilder));
<#+ if(iteration >= 0) { #>
                    for(var i = 0; i < <#=iteration#>; ++i)
                        gen.Emit(OpCodes.Nop);
                    labelBuilder.MarkLabel(gen);
<#+ } #>
                };

                yield return CreateTestCase(
                    $"<#=lName#> <#=iteration#>",
                    expected,
                    actual_label);
                yield return CreateTestCase(
                    $"<#=lName#> <#=iteration#> (builder)",
                    expected,
                    actual_labelBuilder);
            }
<#+
}
#>