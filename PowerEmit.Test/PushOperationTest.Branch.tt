<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Reflection.Emit" #>
<#@ output extension=".g.cs" #>
<#
var opcodes = typeof(OpCodes)
    .GetFields()
    .Where(f => f.FieldType == typeof(OpCode))
    .Select(f => (field: f, opcode: (OpCode)f.GetValue(null)))
    .Where(tpl => tpl.opcode.OperandType == OperandType.InlineBrTarget
               || tpl.opcode.OperandType == OperandType.ShortInlineBrTarget)
    .OrderBy(tpl => tpl.opcode.Value);
#>
// <auto-generated>
// THIS (.g.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using Xunit;

namespace PowerEmit
{
    public partial class PushOperationTest
    {
        [Theory]
        [MemberData(nameof(TestArgs_Branch))]
        private void PushTest_Branch(TestCase testCase)
            => PushTestCore(testCase);

            
        public static IEnumerable<object[]> TestArgs_Branch()
        {
            static Action<ILGenerator> createExpStream_BrToLeading(OpCode opcode, int offset)
                => gen =>
                {
                    var label = gen.DefineLabel();
                    gen.MarkLabel(label);
                    for(var i = 0; i < offset; ++i)
                        gen.Emit(OpCodes.Nop);
                    gen.Emit(opcode, label);
                };
            static Action<ILGenerator> createExpStream_BrToFollowing(OpCode opcode, int offset)
                => gen =>
                {
                    var label = gen.DefineLabel();
                    gen.Emit(opcode, label);
                    for(var i = 0; i < offset; ++i)
                        gen.Emit(OpCodes.Nop);
                    gen.MarkLabel(label);
                };
            static Action<MethodDescription> createActStream_BrToLeading(Action<MethodDescription, LabelDescriptor> push, int offset)
                => desc =>
                {
                    var label = desc.AddLabel("label");
                    desc.Stream.Add(NoOpCode.MarkLabel(label));
                    for(var i = 0; i < offset; ++i)
                        desc.Stream.Add(OpCodeX.Nop());
                    push(desc, label);
                };
            static Action<MethodDescription> createActStream_BrToFollowing(Action<MethodDescription, LabelDescriptor> push, int offset)
                => desc =>
                {
                    var label = desc.AddLabel("label");
                    push(desc, label);
                    for(var i = 0; i < offset; ++i)
                        desc.Stream.Add(OpCodeX.Nop());
                    desc.Stream.Add(NoOpCode.MarkLabel(label));
                };

<# foreach(var (field, opcode) in opcodes) { #>

<# if(opcode.Name.Substring(opcode.Name.Length - 2) == ".s") { #>
            foreach(var i in new []{0, 1, 2, 16, 126})
<# } #>
<# else { #>
            foreach(var i in new []{0, 1, 2, 16, 127, 255, 256, 1024})
<# } #>
            {
                yield return CreateArgs(
                    OpCodes.<#=field.Name#>,
                    createExpStream_BrToLeading(OpCodes.<#=field.Name#>, i),
                    createActStream_BrToLeading((desc, label) => desc.Stream.Add(OpCodeX.<#=field.Name#>(label)), i)
                );
                yield return CreateArgs(
                    OpCodes.<#=field.Name#>,
                    createExpStream_BrToFollowing(OpCodes.<#=field.Name#>, i),
                    createActStream_BrToFollowing((desc, label) => desc.Stream.Add(OpCodeX.<#=field.Name#>(label)), i)
                );
            }
<# } #>
        }
    }
}
