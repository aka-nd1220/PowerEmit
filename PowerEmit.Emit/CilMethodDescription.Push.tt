<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Reflection.Emit" #>
<#@ output extension=".g.cs" #>
<#
var exclusions = new []
{
    OpCodes.Prefix1,
    OpCodes.Prefix2,
    OpCodes.Prefix3,
    OpCodes.Prefix4,
    OpCodes.Prefix5,
    OpCodes.Prefix6,
    OpCodes.Prefix7,
    OpCodes.Prefixref,
};
var opcodes = typeof(OpCodes)
    .GetFields()
    .Where(f => f.FieldType == typeof(OpCode))
    .Select(f => (field: f, opcode: (OpCode)f.GetValue(null)))
    .Where(tpl => !exclusions.Contains(tpl.opcode))
    .OrderBy(tpl => tpl.opcode.Value);
#>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using PowerEmit.Emit.Linq;

namespace PowerEmit.Emit
{
    partial class CilMethodDescription
    {
<#
foreach(var (field, opcode) in opcodes)
{
#>
<#=GetMembers(field, opcode)#>

<#
}
#>
    }
}
<#+
OpCode[] clsIncompliantOpCodes = new []
{
    OpCodes.Ldc_I4_S,
};


string GetMembers(FieldInfo field, OpCode opcode)
{
    if(opcode == OpCodes.Calli)
    {
        return @"
        /* calli was skipped. */";
    }
    if(opcode == OpCodes.Ldc_I4_S)
    {
        return $@"{GetDocString(opcode)}
        [CLSCompliant(false)]
        public {field.Name} Push_{field.Name}(sbyte operand)
        {{
            var op = new Ldc_I4_S(operand);
            _operations.Add(op);
            return op;
        }}";
    }
    if(opcode == OpCodes.Switch)
    {
        return $@"{GetDocString(opcode)}
        public {field.Name} Push_{field.Name}(IEnumerable<CilLabel> operand)
        {{
            var op = new {field.Name}(operand);
            _operations.Add(op);
            return op;
        }}
        
        {GetDocString(opcode)}
        public {field.Name} Push_{field.Name}(params CilLabel[] operand)
        {{
            var op = new {field.Name}(operand);
            _operations.Add(op);
            return op;
        }}";
    }
    if(opcode == OpCodes.Ldtoken)
    {
        return $@"{GetDocString(opcode)}
        public Ldtoken Push_Ldtoken(Type operand)
        {{
            var op = new Ldtoken(operand);
            _operations.Add(op);
            return op;
        }}
        
        {GetDocString(opcode)}
        public Ldtoken Push_Ldtoken(FieldInfo operand)
        {{
            var op = new {field.Name}(operand);
            _operations.Add(op);
            return op;
        }}
        
        {GetDocString(opcode)}
        public Ldtoken Push_Ldtoken(MethodInfo operand)
        {{
            var op = new {field.Name}(operand);
            _operations.Add(op);
            return op;
        }}";
    }

    if(opcode.OperandType == OperandType.InlineNone)
    {
        return $@"{GetDocString(opcode)}
        public {field.Name} Push_{field.Name}()
        {{
            var op = new {field.Name}();
            _operations.Add(op);
            return op;
        }}";
    }
    else
    {
        return $@"{GetDocString(opcode)}
        public {field.Name} Push_{field.Name}({GetArgType(opcode)} operand)
        {{
            var op = new {field.Name}(operand);
            _operations.Add(op);
            return op;
        }}";
    }
}



string GetDocString(OpCode opcode)
{
    var retval = $@"
        /// <summary>
        /// Pushes a new {opcode.Name} operation entry onto IL operation queue of this description.
        /// </summary>";
    switch(opcode.OperandType)
    {
    case OperandType.InlineNone:
        break;
    }
    retval += @"
        /// <returns></returns>";
    return retval;
}


string GetArgType(OpCode opcode)
{
    switch(opcode.OperandType)
    {
    case OperandType.InlineBrTarget:
        return "CilLabel";
    case OperandType.InlineField:
        return "FieldInfo";
    case OperandType.InlineI:
        return "int";
    case OperandType.InlineI8:
        return "long";
    case OperandType.InlineMethod:
        return opcode == OpCodes.Newobj
               ? "ConstructorInfo"
               : "MethodInfo";
    case OperandType.InlineNone:
        return "";
#pragma warning disable CS0618
    case OperandType.InlinePhi:
        goto default;
#pragma warning restore CS0618
    case OperandType.InlineR:
        return "double";
    case OperandType.InlineSig:
        goto default;
    case OperandType.InlineString:
        return "string";
    case OperandType.InlineSwitch:
        goto default;
    case OperandType.InlineTok:
        goto default;
    case OperandType.InlineType:
        return "Type";
    case OperandType.InlineVar:
        return "short";
    case OperandType.ShortInlineBrTarget:
        return "CilLabel";
    case OperandType.ShortInlineI:
        return "byte";
    case OperandType.ShortInlineR:
        return "float";
    case OperandType.ShortInlineVar:
        return "byte";
    default:
        return "object";
    }
}

#>